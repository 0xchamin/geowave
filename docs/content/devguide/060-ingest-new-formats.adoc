[[ingest-new-formats]]
<<<
[[ingest-new-formats]]
=== New Formats

:linkattrs:

There are multiple ways to get data into GeoWave. In other sections we will discuss higher order frameworks, mapreduce
interfaces, etc. The intent here is "just the basics" â€” the least framework intensive way that one can load
geospatial data.

Information here will reference the link:https://github.com/locationtech/geowave/blob/master/examples/src/main/java/mil/nga/giat/geowave/examples/ingest/SimpleIngest.java[SimpleIngest, window="_blank"] and link:https://github.com/locationtech/geowave/blob/master/examples/src/main/java/mil/nga/giat/geowave/examples/ingest/SimpleIngestProducerConsumer.java[SimpleIngestProducerConsumer, window="_blank"] examples in the geowave-examples project.

.Supported DataStores:
* <<060-ingest-new-formats.adoc#accumulo-datastore, Accumulo DataStore>>
* <<060-ingest-new-formats.adoc#hbase-datastore, HBase DataStore>>

==== Minimum information needed

Geowave requires these pieces of fundamental information in order to persist data:

[[accumulo-datastore]]
.Accumulo DataStore
* link:https://github.com/locationtech/geowave/blob/master/extensions/datastores/accumulo/src/main/java/mil/nga/giat/geowave/datastore/accumulo/BasicAccumuloOperations.java[BasicAccumuloOperations, window="_blank"] object
** This class contains the information required to connect to an accumulo instance and which table to use in accumulo.
** Zookeepers: in the format zookeeper1:port,zookeeper2:port,etc...
** Accumulo Instance ID: this is the "instance" that the Accumulo cluster you are connecting to was initialized with. It's a global setting per cluster.
** Accumulo Username: this is the name of the user you would like to connect as. This is a user account managed by accumulo, not a system, etc. user.
** Accumulo Password: this is the password associated with the user specified above. Again, this is an accumulo controlled secret.
** Geowave Namespace: this is _not_ an Accumulo namespace. Think of it as a prefix GeoWave will use on any tables it creates. The only current constraint is only one index type is allowed per namespace.
* SimpleFeatureType instance
** http://www.opengeospatial.org/standards/sfs[Simple Feature Types] are an OGC specification for defining geospatial features. Leveraging this standard is one of the easiest ways to get GIS data into GeoWave.
** SimpleFeatureType instance (link:http://docs.geotools.org/stable/javadocs/org/opengis/feature/simple/SimpleFeatureType.html[org.opengis.feature.simple.SimpleFeatureType, window="_blank"]): this defines the names, types, and other metadata (nullable, etc) of a feature. Think of it as a map of name:values where the values are typed.
* DataAdapter instance
** A GeoWave data adapter is an implementation of the DataAdapter interface that handles the persistence serialization of whatever the object you are storing.
** We are storing SimpleFeatures, so we can leverage the provided FeatureDataAdapter.
* Index instance
** The final piece needed as the index defines which attributes are indexed and how that index is constructed.
* DataStore
** This is the piece that puts everything above together.
** Initialization required a BasicAccumuloOperations instance. The rest are provided as parameters for calls that need them.

[[hbase-datastore]]
.HBase DataStore
* link:https://github.com/locationtech/geowave/blob/master/extensions/datastores/hbase/src/main/java/mil/nga/giat/geowave/datastore/hbase/operations/BasicHBaseOperations.java[BasicHBaseOperations, window="_blank"] object
** This class contains the information required to connect to an hbase instance - and which table to use in hbase.
** Zookeepers: in the format zookeeper1:port,zookeeper2:port,etc...
** Geowave Namespace: this is _not_ an HBase namespace; rather think of it as a prefix geowave will use on any tables it creates. The only current constraint is only one index type is allowed per namespace.
* SimpleFeatureType instance
** http://www.opengeospatial.org/standards/sfs[Simple Feature Types] are an OGC specification for defining geospatial features. Leveraging this standard is one of the easiest ways to get GIS data into GeoWave.
** SimpleFeatureType instance (link:http://docs.geotools.org/stable/javadocs/org/opengis/feature/simple/SimpleFeatureType.html[org.opengis.feature.simple.SimpleFeatureType, window="_blank"]): this defines the names, types, and other metadata (nullable, etc) of a feature. Think of it as a map of name:values where the values are typed.
* DataAdapter instance
** A GeoWave data adapter is an implementation of the DataAdapter interface that handles the persistence serialization of whatever the object you are storing.
** We are storing SimpleFeatures, so we can leverage the provided FeatureDataAdapter.
* Index instance
** The final piece needed as the index defines which attributes are indexed and how that index is constructed.
* DataStore
** This is the piece that puts everything above together.
** Initialization required a BasicHBaseOperations instance, the rest are provided as parameters for calls which need them.


==== Ingest some data

Here we will programmatically generate a grid of points at each location where a whole number latitude and longitude intersect. In this example, we will walk you through the different components involved with ingesting. For reference, this is all through the link:https://github.com/locationtech/geowave/blob/master/examples/src/main/java/mil/nga/giat/geowave/examples/ingest/SimpleIngest.java[SimpleIngest, window="_blank"] example class.

[NOTE]
====
It is important to note that this is meant to be a developer-focused walkthrough of the components involved in ingesting data. For an exhaustive guide with a DevOp's focused tailoring, please reference the please reference the http://locationtech.github.io/geowave/quickstart.html[Quickstart Guide, window="_blank"].
====

===== Ingesting Data Into Accumulo
Here we will outline what is involved in ingesting data into accumulo - from the accumulo operations to generating feature types, indexes, and adapters.

. <<060-ingest-new-formats.adoc#basic-accumulo-operations, Basic Accumulo Operations>>
. <<060-ingest-new-formats.adoc#accumulo-simple-feature-type, Simple Feature Type>>
. <<060-ingest-new-formats.adoc#accumulo-spatial-index, Spatial index>>
. <<060-ingest-new-formats.adoc#accumulo-data-adapter, Data Adapter>>
. <<060-ingest-new-formats.adoc#accumulo-generating-points, Generating and loading points>>


[[basic-accumulo-operations]]
====== Basic Accumulo Operations

[source, java]
----
/***
 * The class tells geowave about the accumulo instance it should connect to,
 * as well as what tables it should create/store it's data in
 *
 * @param zookeepers
 *          Zookeepers associated with the accumulo instance, comma separate
 * @param accumuloInstance  Accumulo instance name
 * @param accumuloUser      User geowave should connect to accumulo as
 * @param accumuloPass      Password for user to connect to accumulo
 * @param geowaveNamespace
 *      Different than an accumulo namespace (unfortunate naming usage) - this is
 *      basically a prefix on the table names geowave uses.
 * @return  Object encapsulating the accumulo connection information
 * @throws AccumuloException
 * @throws AccumuloSecurityException
 */
protected BasicAccumuloOperations getAccumuloInstance(String zookeepers,
                String accumuloInstance, String accumuloUser,
                String accumuloPass, String geowaveNamespace)
  throws AccumuloException, AccumuloSecurityException {
    return new BasicAccumuloOperations(zookeepers, accumuloInstance,
                        accumuloUser, accumuloPass, geowaveNamespace);
}
----

[[accumulo-simple-feature-type]]
====== Simple Feature Type

A geometry field is required. Everything else is really optional. It's often convenient to add a text
latitude and longitude field for ease of display values (getFeatureInfo, etc.).

[source, java]
----
/***
 * A simple feature is just a mechanism for defining attributes (a feature is just a
 * collection of attributes + some metadata)
 * We need to describe what our data looks like so the serializer (FeatureDataAdapter for
 * this case) can know how to store it.
 * Features/Attributes are also a general convention of GIS systems in general.
 * @return Simple Feature definition for our demo point feature
 */
protected SimpleFeatureType createPointFeatureType(){

    final SimpleFeatureTypeBuilder builder = new SimpleFeatureTypeBuilder();
    final AttributeTypeBuilder ab = new AttributeTypeBuilder();


    // Names should be unique (at least for a given GeoWave namespace) - think about
    // names in the same sense as a full classname
    // The value you set here will also persist through discovery - so when people are
    // looking at a dataset they will see the type names associated with the data.
    builder.setName("Point");

    // The data is persisted in a sparse format, so if data is nullable it will not take
    // up any space if no values are persisted.
    // Data which is included in the primary index (in this example lattitude/longtiude)
    // cannot be null
    // Calling out latitude an longitude separately is not strictly needed, as the
    // geometry contains that information.  But it's convienent in many use cases to get
    // a text representation without having to handle geometries.
    builder.add(ab.binding(Geometry.class).nillable(false).buildDescriptor("geometry"));
    builder.add(ab.binding(Date.class).nillable(true).buildDescriptor("TimeStamp"));
    builder.add(ab.binding(Double.class).nillable(false).buildDescriptor("Latitude"));
    builder.add(ab.binding(Double.class).nillable(false).buildDescriptor("Longitude"));
    builder.add(ab.binding(String.class).nillable(true).buildDescriptor("TrajectoryID"));
    builder.add(ab.binding(String.class).nillable(true).buildDescriptor("Comment"));

    return builder.buildFeatureType();
}
----

[[accumulo-spatial-index]]
====== Spatial index

[source, java]
----
/***
 * We need an index model that tells us how to index the data - the index determines
 *   - What fields are indexed
 *   - The precision of the index
 *   - The range of the index (min/max values)
 *   - The range type (bounded/unbounded)
 *   - The number of "levels"  (different precisions, needed when the values indexed has
 *     ranges on any dimension)
 * @return GeoWave index for a default SPATIAL index
 */
protected Index createSpatialIndex(){

    // Reasonable values for spatial and spatio-temporal are provided through static
    // factory methods. They are intended to be a reasonable starting place - though
    // creating a custom index may provide better performance is the
    // distribution/characterization of the data is well known.
    return IndexType.SPATIAL.createDefaultIndex();
}
----

[[accumulo-data-adapter]]
====== Data Adapter

[source, java]
----
/***
 * The dataadapter interface describes how to serialize a data type.
 * Here we are using an implementation that understands how to serialize
 * OGC SimpleFeature types.
 * @param sft  simple feature type you want to generate an adapter from
 * @return data adapter that handles serialization of the sft simple feature type
 */
protected FeatureDataAdapter createDataAdapter(SimpleFeatureType sft){
    return new FeatureDataAdapter(sft);
}
----

[[accumulo-generating-points]]
====== Generating and loading points

[source, java]
----
protected void generateGrid(
            final BasicAccumuloOperations bao ) {

        // create our datastore object
        final DataStore geowaveDataStore = getGeowaveDataStore(bao);

        // In order to store data we need to determine the type of data store
        final SimpleFeatureType point = createPointFeatureType();

        // This a factory class that builds simple feature objects based on the
        // type passed
        final SimpleFeatureBuilder pointBuilder = new SimpleFeatureBuilder(
                point);

        // This is an adapter, that is needed to describe how to persist the
        // data type passed
        final FeatureDataAdapter adapter = createDataAdapter(point);

        // This describes how to index the data
        final Index index = createSpatialIndex();

        // features require a featureID - this should be unqiue as it's a
        // foreign key on the feature (i.e. sending in a new feature with
        // the same feature id will overwrite the existing feature)
        int featureId = 0;

        // get a handle on a GeoWave index writer which wraps the Accumulo
        // BatchWriter, make sure to close it (here we use a try with resources
        // block to close it automatically)
        try (IndexWriter indexWriter = geowaveDataStore.createIndexWriter(index)) {
            // build a grid of points across the globe at each whole
            // lattitude/longitude intersection
            for (int longitude = -180; longitude <= 180; longitude++) {
                for (int latitude = -90; latitude <= 90; latitude++) {
                    pointBuilder.set(
                            "geometry",
                            GeometryUtils.GEOMETRY_FACTORY.createPoint(new Coordinate(
                                    longitude,
                                    latitude)));
                    pointBuilder.set(
                            "TimeStamp",
                            new Date());
                    pointBuilder.set(
                            "Latitude",
                            latitude);
                    pointBuilder.set(
                            "Longitude",
                            longitude);
                    // Note since trajectoryID and comment are marked as
                    // nillable we don't need to set them (they default ot null).

                    final SimpleFeature sft = pointBuilder.buildFeature(
                                                    String.valueOf(featureId));
                    featureId++;
                    indexWriter.write(
                            adapter,
                            sft);
                }
            }
        }
        catch (final IOException e) {
            log.warn(
                    "Unable to close index writer",
                    e);
        }
    }
----

==== Other methods

There are other patterns that can be used. See the various classes in the 'geowave-examples' project. The method displayed above is the suggested pattern and is demonstrated in SimpleIngestIndexWriter.java

The other methods displayed work, but are either more complicated than necessary (SimpleIngestProducerConsumer.java) or not very efficient (SimpleIngest.java).
